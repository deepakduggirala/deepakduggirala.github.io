import{_ as e,c as o,o as r,a as i}from"./app.5f69941c.js";const u='{"title":"Master Theorem","description":"","frontmatter":{},"headers":[{"level":3,"title":"Case1: Work to split/recombine a problem is dwarfed by subproblems.","slug":"case1-work-to-split-recombine-a-problem-is-dwarfed-by-subproblems"},{"level":3,"title":"Case2: Work to split/recombine a problem is comparable to subproblems.","slug":"case2-work-to-split-recombine-a-problem-is-comparable-to-subproblems"},{"level":3,"title":"Case3: Work to split/recombine a problem dominates subproblems.","slug":"case3-work-to-split-recombine-a-problem-dominates-subproblems"}],"relativePath":"Algorithms/Master Theorem.md"}',t={name:"Algorithms/Master Theorem.md"},l=i('<h1 id="master-theorem" tabindex="-1">Master Theorem <a class="header-anchor" href="#master-theorem" aria-hidden="true">#</a></h1><p>20210210202551</p><p>Source: <a href="https://en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms)" target="_blank" rel="noopener noreferrer">https://en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms)</a></p><ul><li>For divide and conquer algorithms implemented recursively, the runtime will be of the form $T(n) = aT(n/b) + f(n)$ for $n &gt; h$ and has direct value for $n &lt; h$ <ul><li>At each level, the problem is split up into $a$ parts of size $n/b$</li><li>$f(n)$ is the cost of splitting up and combining the solutions of the sub problems</li></ul></li><li>Master\u2019s theorem gives solution to these kind of recurrence relations without actually expanding and solving them.</li><li>It defines a critical exponent to weight the work required for solving subproblems and work required to splitting and combining them. $c_{crit} = log_ba$</li><li>Define c to be $f(n) = kn^c = O(c)$. see [[20210210201718]] Asymptotic Analysis</li></ul><h3 id="case1-work-to-split-recombine-a-problem-is-dwarfed-by-subproblems" tabindex="-1">Case1: Work to split/recombine a problem is dwarfed by subproblems. <a class="header-anchor" href="#case1-work-to-split-recombine-a-problem-is-dwarfed-by-subproblems" aria-hidden="true">#</a></h3><ul><li>Recursion tree is leaf heavy</li><li>If $c &lt; c_{crit}$, then $T(n) = \\Theta(n^{c_{crit}})$</li><li>Example: $T(n) = 2T(n/2) + k$ <ul><li>$c_{crit} = log_22 = 1$</li><li>$c = 0$</li><li>$T(n) = \\Theta(n)$</li></ul></li></ul><h3 id="case2-work-to-split-recombine-a-problem-is-comparable-to-subproblems" tabindex="-1">Case2: Work to split/recombine a problem is comparable to subproblems. <a class="header-anchor" href="#case2-work-to-split-recombine-a-problem-is-comparable-to-subproblems" aria-hidden="true">#</a></h3><ul><li>If $c \\approx c_{crit}$, such that $c = \\Theta(n^{c_{crit}}log^kn)$ then $T(n) = \\Theta(n^{c_{crit}}log^{k+1}n)$</li><li>Example: Merge Sort, $T(n) = 2T(n/2) + c.n$ <ul><li>$c_{crit} = log_22 = 1$</li><li>$c = 1$ and $k = 0$</li><li>$T(n) = \\Theta(nlogn)$</li></ul></li></ul><h3 id="case3-work-to-split-recombine-a-problem-dominates-subproblems" tabindex="-1">Case3: Work to split/recombine a problem dominates subproblems. <a class="header-anchor" href="#case3-work-to-split-recombine-a-problem-dominates-subproblems" aria-hidden="true">#</a></h3><ul><li>Recursion tree is root heavy</li><li>This doesn\u2019t necessarily yeild anything</li><li>If $af(n/b) \u2264 kf(n)$ for some value of $k &lt; 1$ then $T(n) = \\Theta(f(n))$</li></ul>',10),a=[l];function s(n,c,m,b,p,h){return r(),o("div",null,a)}var $=e(t,[["render",s]]);export{u as __pageData,$ as default};
