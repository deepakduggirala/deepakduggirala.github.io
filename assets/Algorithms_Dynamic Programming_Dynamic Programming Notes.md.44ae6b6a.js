import{_ as e,c as i,o,a as t}from"./app.5f69941c.js";const g='{"title":"Dynamic Programming Notes","description":"","frontmatter":{},"headers":[{"level":3,"title":"Naive Approach","slug":"naive-approach"},{"level":3,"title":"Memoization","slug":"memoization"},{"level":3,"title":"Startegies of expressing the problem as function of sub-problems","slug":"startegies-of-expressing-the-problem-as-function-of-sub-problems"},{"level":2,"title":"Problems","slug":"problems"}],"relativePath":"Algorithms/Dynamic Programming/Dynamic Programming Notes.md"}',a={name:"Algorithms/Dynamic Programming/Dynamic Programming Notes.md"},s=t('<h1 id="dynamic-programming-notes" tabindex="-1">Dynamic Programming Notes <a class="header-anchor" href="#dynamic-programming-notes" aria-hidden="true">#</a></h1><p>20200903174015</p><p>Source: <a href="https://github.com/deepakduggirala/Algorithms/wiki/Dynamic-Programming" target="_blank" rel="noopener noreferrer">https://github.com/deepakduggirala/Algorithms/wiki/Dynamic-Programming</a></p><p>Dynamic Programming is formulated upon recursion. In solving a problem you need to take decisions, for every decision if you can answer the question by comparing two outcomes of the decision instead of following a path irreversibly (what we do in the greedy approach) it is called dynamic programming. Also the solutions of the two outcomes must be expressed as solving the same problem (before the decision) but with smaller inputs. This is called expressing the problem as solution of sub-problems.</p><h3 id="naive-approach" tabindex="-1">Naive Approach <a class="header-anchor" href="#naive-approach" aria-hidden="true">#</a></h3><ol><li>Express the problem as combination of sub-problems at a decision step.</li><li>Establish base conditions.</li><li>Solve the sub-problems recursively.</li></ol><h3 id="memoization" tabindex="-1">Memoization <a class="header-anchor" href="#memoization" aria-hidden="true">#</a></h3><p>In the naive approach we solve the same sub-problems again and again and also the overhead for recursion is large.</p><ul><li>One approach is to store answers for every sub-problem and look up every time when we solve another. Analogy: Going to all leaves starting from root evaluating each path.</li><li>Another approach called BOTTOM-UP is based on predicting the interaction between sub-problems and simulating them starting from base case. Analogy starting from leaves and reaching root.</li></ul><h3 id="startegies-of-expressing-the-problem-as-function-of-sub-problems" tabindex="-1">Startegies of expressing the problem as function of sub-problems <a class="header-anchor" href="#startegies-of-expressing-the-problem-as-function-of-sub-problems" aria-hidden="true">#</a></h3><ul><li>Divide and Conquer <ul><li>Split the input into two halves <ul><li>merge the solutions of both the halves ex: merge sort</li><li>merge left solution, right solution, and other possible solutions which involve inputs in both left and right halves. <ul><li>ex: closest pair of points</li><li>make sure that complexity of finding other possible solutions which involve inputs in both left and right halves is less then <code>O(n)</code>. so that the entire complexity will be <code>O(nlogn)</code>. see Master&#39;s equation? <code>T(n) = 2*T(n/2) + O(n)</code></li></ul></li></ul></li></ul></li><li>Express the solution of <code>f(i)</code> as a function of previous inputs&#39; solutions <code>f(i-1), f(i-2) ...</code><ul><li>This pattern is seen in fibonacci numbers (i-1, i-2), Markov chains and many other problems</li></ul></li><li>Pick a <strong>pivot element</strong> and split / rearrange the input according to it and recursively solve the sub problems <ul><li>ex: Largest rectangle in a histogram, divide and conquer approach, we select the minimum bar and split the histogram based on that.</li><li>ex: quick sort, we select a pivot and split the input, such that elements less than the pivot will be on side and elements more than the pivot will be on the other.</li><li>We can use datastructures to find the pivot efficiently</li></ul></li></ul><h2 id="problems" tabindex="-1">Problems <a class="header-anchor" href="#problems" aria-hidden="true">#</a></h2><ul><li>[[20200902211339]] Divisor Game</li><li>[[20200902223758]] Best Time to Buy and Sell Stock</li><li>[[20200903174132]] Min Cost Climbing Stairs</li><li>[[20200904120107]] Range Sum</li><li>[[20200904153543]] House Robber</li><li>[[20200904212600]] Count Square Sub-matrices with all Ones</li><li>[[20200903194906]] Is Subsequence</li><li>[[20200904175821]] Matrix Block Sum</li></ul>',13),n=[s];function r(l,h,m,c,p,u){return o(),i("div",null,n)}var b=e(a,[["render",r]]);export{g as __pageData,b as default};
