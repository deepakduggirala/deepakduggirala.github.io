import{_ as e,c as i,o as t,a as n}from"./app.5f69941c.js";const g='{"title":"Dynamic Programming","description":"","frontmatter":{},"headers":[{"level":3,"title":"Induction","slug":"induction"},{"level":3,"title":"Memoization","slug":"memoization"},{"level":3,"title":"Patterns in Induction","slug":"patterns-in-induction"}],"relativePath":"Algorithms/Dynamic Programming/Dynamic Programming.md"}',o={name:"Algorithms/Dynamic Programming/Dynamic Programming.md"},a=n('<h1 id="dynamic-programming" tabindex="-1">Dynamic Programming <a class="header-anchor" href="#dynamic-programming" aria-hidden="true">#</a></h1><p>20200906120044</p><p>Dynamic Programming if finding the inductive solution and using memoization to solve the each sub-problem only once.</p><h3 id="induction" tabindex="-1">Induction <a class="header-anchor" href="#induction" aria-hidden="true">#</a></h3><p>Express the problem as merging the solved sub-problems and establishing the solutions to base cases.</p><h3 id="memoization" tabindex="-1">Memoization <a class="header-anchor" href="#memoization" aria-hidden="true">#</a></h3><p>This may have overlapping sub-problems. Identifying the pattern in which sub-problems develop and finding out the structure to store the values of smaller sub-problems which are to be used when finding solutions of larger sub-problems. Another way of saying, If the sub-problems form a dependency graph, find out the Directed Acyclic Graph (DAG) and start from the base cases and go up the DAG.</p><h3 id="patterns-in-induction" tabindex="-1">Patterns in Induction <a class="header-anchor" href="#patterns-in-induction" aria-hidden="true">#</a></h3><ul><li>Split the problem space, solve the subprobelms and merge (also called Divide and Conquer) <ul><li>Use symmetry to split into two halves (more than 2 if symmetry supports)</li><li>merging the sub-solutions include concatenating, finding the max. min of these, adding them or any other function of these sub-problems.</li></ul></li><li>Choice: <ul><li>Exclude one element, compute the solution of the n-1 sub-problem and compare this with solution where this element is included.</li></ul></li><li>Selecting a pivot element and split according to this. <ul><li>The pivot element is chosen to make the merging the sub-solutions feasible.</li><li>If any other element is used to split, the solution to the problem cannot be expressed in the terms of sub-solutions alone.</li><li>see Divide and conquer solution of &quot;Largest Rectangle in a Histogram&quot;</li></ul></li></ul>',9),s=[a];function r(l,m,h,d,c,u){return t(),i("div",null,s)}var b=e(o,[["render",r]]);export{g as __pageData,b as default};
